#!/usr/bin/env python3
import sys
import os
import json
from typing import List, Tuple

import cv2
import numpy as np


def find_yellow_centers(img_path: str) -> List[Tuple[float, float]]:
    img = cv2.imread(img_path)
    if img is None:
        raise FileNotFoundError(f"Could not read image: {img_path}")

    # Convert to HSV for robust yellow detection
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # Build a union mask from several plausible yellow ranges
    # This is robust across different encodings/screenshots
    ranges = [
        (np.array([15, 80, 140]), np.array([50, 255, 255])),
        (np.array([18, 60, 130]), np.array([60, 255, 255])),
        (np.array([20, 100, 160]), np.array([40, 255, 255])),
    ]
    masks = [cv2.inRange(hsv, lo, hi) for (lo, hi) in ranges]
    mask = masks[0]
    for m in masks[1:]:
        mask = cv2.bitwise_or(mask, m)

    # Light morphology to reduce speckle without merging neighboring dots
    kernel = np.ones((3, 3), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)

    # Find contours
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    centers: List[Tuple[float, float]] = []
    # Adaptive area filtering to accommodate varying dot sizes across screenshots
    # Compute dynamic min/max bounds from the contour area distribution
    h, w = mask.shape
    raw_areas = [cv2.contourArea(c) for c in contours if cv2.contourArea(c) > 0]
    if raw_areas:
        arr = np.array(raw_areas, dtype=np.float32)
        med = float(np.median(arr))
        q1 = float(np.percentile(arr, 25))
        q3 = float(np.percentile(arr, 75))
        iqr = max(1.0, q3 - q1)
        # Base bounds around median with IQR padding
        dyn_min = max(2.0, 0.3 * med)
        dyn_max = max(0.01 * w * h, med + 3.0 * iqr, 3.5 * med)
    else:
        dyn_min = 2.0
        dyn_max = 0.02 * w * h

    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area < dyn_min or area > dyn_max:
            continue
        M = cv2.moments(cnt)
        if M["m00"] == 0:
            continue
        cx = M["m10"] / M["m00"]
        cy = M["m01"] / M["m00"]
        centers.append((float(cx), float(cy)))

    # Also run blob detection on the mask to catch missed small/faint dots
    params = cv2.SimpleBlobDetector_Params()
    params.filterByColor = True
    params.blobColor = 255
    params.minThreshold = 10
    params.maxThreshold = 255
    params.thresholdStep = 10
    params.filterByArea = True
    params.minArea = 5
    params.maxArea = max(10000, int(0.01 * w * h))
    params.filterByCircularity = False
    params.filterByConvexity = False
    params.filterByInertia = False
    detector = cv2.SimpleBlobDetector_create(params)
    keypoints = detector.detect(mask)
    for k in keypoints:
        centers.append((float(k.pt[0]), float(k.pt[1])))

    # De-duplicate and snap: merge close points using radius-based NMS
    if len(centers) > 0:
        pts = np.array(centers, dtype=np.float32)
        # radius tuned as a fraction of min(img dims)
        r = max(2.0, 0.006 * max(w, h))
        taken = np.zeros(len(pts), dtype=bool)
        merged: List[Tuple[float, float]] = []
        for i in range(len(pts)):
            if taken[i]:
                continue
            close_idx = [i]
            for j in range(i + 1, len(pts)):
                if taken[j]:
                    continue
                if np.hypot(*(pts[i] - pts[j])) <= r:
                    close_idx.append(j)
                    taken[j] = True
            grp = pts[close_idx]
            mean = grp.mean(axis=0)
            merged.append((float(mean[0]), float(mean[1])))
        centers = merged

    # Sort for deterministic output (top-to-bottom, then left-to-right)
    centers.sort(key=lambda p: (round(p[1], 2), round(p[0], 2)))
    return centers


def write_ts(coords: List[Tuple[float, float]], out_path: str, export_name: str = "schrodingersPatternCoordinates"):
    # We output in image pixel coordinates; QuantumCat fits to canvas
    lines = []
    lines.append("// Auto-generated by scripts/extract_pattern.py\n")
    lines.append(f"export const {export_name}: {{x: number, y: number}}[] = [\n")
    # Normalize to a smaller numeric range to reduce file size? Not necessary.
    # Keep full precision for exact fit; round to 3 decimals to keep TS readable.
    for (x, y) in coords:
        lines.append(f"  {{x: {x:.3f}, y: {y:.3f}}},\n")
    if lines[-1].endswith(',\n'):
        lines[-1] = lines[-1][:-2] + "\n"
    lines.append("];\n")

    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, "w", encoding="utf-8") as f:
        f.writelines(lines)


def main():
    if len(sys.argv) < 2:
        print("Usage: python scripts/extract_pattern.py <image_path> [<out_ts_path>]", file=sys.stderr)
        sys.exit(1)
    img_path = sys.argv[1]
    out_path = sys.argv[2] if len(sys.argv) >= 3 else os.path.join(
        os.path.dirname(__file__), "..", "src", "components", "SchrodingersPattern.ts"
    )
    export_name = sys.argv[3] if len(sys.argv) >= 4 else "schrodingersPatternCoordinates"
    out_path = os.path.abspath(out_path)

    centers = find_yellow_centers(img_path)
    print(f"Detected {len(centers)} dots")
    write_ts(centers, out_path, export_name)
    print(f"Wrote coordinates to {out_path}")

    # Optional debug preview image of detections
    try:
        img = cv2.imread(img_path)
        for (x, y) in centers:
            cv2.circle(img, (int(round(x)), int(round(y))), 4, (0, 0, 255), 2)
        dbg_dir = os.path.join(os.path.dirname(__file__), "..", "scripts", "output")
        os.makedirs(dbg_dir, exist_ok=True)
        dbg_path = os.path.abspath(os.path.join(dbg_dir, "detections_preview.png"))
        cv2.imwrite(dbg_path, img)
        print(f"Saved debug preview: {dbg_path}")
    except Exception as e:
        print(f"Debug preview failed: {e}")


if __name__ == "__main__":
    main()
